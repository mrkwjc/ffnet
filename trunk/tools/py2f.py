########################################################################
##  Copyright (C) 2006 by Marek Wojciechowski
##  <mwojc@p.lodz.pl>
##
##  Distributed under the terms of the GNU General Public License (GPL)
##  http://www.gnu.org/copyleft/gpl.html
########################################################################

"""
Helper functions to create fortran code from within python
"""

def flines(string = ' '):
    if string == '': string == ' '
    lines = string.splitlines()
    fstr = ''
    for line in lines:
        fstr += ' ' * 6 + line + '\n'
    return fstr

def fcomment(string = ' '):
    if string == '': string == ' '
    lines = string.splitlines()
    fstr = ''
    for line in lines:
        fstr += 'c' + ' ' * 5 + line + '\n'
    return fstr

def addfline(string=' '):  # not very smart solution (should be in flines?)
    if string == '': string == ' '
    return ' '*5 + '& ' + string + '\n'

def farray(arr, fname):
    shp = arr.shape
    if len(shp) == 1: 
        fshp = '(%i)' %shp[0]
    else:
        fshp = str(shp)
    typ = arr.dtype
    
    if typ in [ 'int32', 'int64' ]: ftyp = 'INTEGER '
    elif typ == 'float32': ftyp = 'REAL '
    elif typ == 'float64': ftyp = 'DOUBLE PRECISION '
    else: raise TypeError("Unsupported array type")
    
    declaration = flines ( ftyp + fname + fshp )
    
    indexes = [ [ i ] for i in range(shp[0]) ]
    findexes = [ [ i + 1 ] for i in range(shp[0]) ]
    try:
    #if 1:
        for idx in shp[1:]:
            newindexes = []
            newfindexes = []
            for i in range(idx):
                for j in xrange( len(indexes) ):
                    newindexes += [ indexes[j] + [i] ]
                    newfindexes += [ findexes[j] + [i + 1] ]
            indexes = newindexes[:]
            findexes = newfindexes[:]
    except: pass
    indexes = [ tuple(i) for i in indexes ] 
    if len(shp) == 1: 
        findexes = [ '(%i)' %idx[0] for idx in findexes ]
    else:
        findexes = [ str(tuple(idx)) for idx in findexes ]
    
    definition = ''
    for i in xrange( len(indexes) ):
        fval = str ( arr[ indexes[i] ] )
        definition += flines ( fname + findexes[i] + ' = ' + fval )
        
    return declaration, definition

def fnumber(number, fname):
    typ = type(number).__name__
    if typ == 'int': ftyp = 'INTEGER '
    elif typ == 'float': ftyp = 'DOUBLE PRECISION '
    else: raise TypeError("Unsupported variable type")

    fval = str(number)
    
    declaration = flines ( ftyp + fname )
    definition = flines ( fname + ' = ' + fval )
    
    return declaration, definition
    
def fstring(string, fname):
    typ = type(string).__name__
    if typ == 'str': 
        length = len(string)
        ftyp = 'CHARACTER*%i ' %(length)
    else: raise TypeError("Provide a string")
        
    declaration = flines ( ftyp + fname )
    definition = flines ( fname + ' = ' + "'" + string + "'" )
    
    return declaration, definition
    
def fexport(variable, fname):
    if type(variable).__name__ == 'ndarray':
        return farray(variable, fname)
    elif type(variable).__name__ in ['int', 'float']:
        return fnumber(variable, fname)
    elif type(variable).__name__ == 'str':
        return fstring(variable, fname)

def netexport(net, fname):
    # Preparing limits strings
    inlimits = ''; outlimits = ''
    for i, line in enumerate(net.inlimits):
        inlimits += flines ( '%i --> %s' %(i+1, str(line)) )
    for o, line in enumerate(net.outlimits):
        outlimits += flines ( '%i --> %s' %(o+1, str(line)) )

    initcomment = \
"""##################################################################
THIS FILE IS AUTOMATICALLY GENERATED WITH:

ffnet - feed-forward neural network for python
http://ffnet.sourceforge.net

Copyright (C) 2006 by Marek Wojciechowski
<mwojc@p.lodz.pl>
 
Distributed under the terms of the GNU General Public License:
http://www.gnu.org/copyleft/gpl.html
##################################################################
 
NETWORK SPECIFICATION
%s

INPUT LIMITS
%s
OUTPUT LIMITS
%s
WARNING: You need 'ffnet.f' file distributed with ffnet 
         sources to  get the below routines to work.
""" %(net.__repr__(), inlimits, outlimits)
    initcomment = fcomment ( initcomment )

    # Network routine definition
    netroutine = flines ( 'SUBROUTINE ' + fname + '(input, output)' )
    
    # Network variables export
    declarations = ''
    definitions = ''
    # array lengths
    n = len(net.conec); u = len(net.units); i = len(net.inno); o = len(net.outno)
    # defined arrays
    arrs =  [ 'conec', 'inno', 'outno', 'weights', 'eni', 'deo' ]
    for name in arrs:
        deftuple = fexport ( net.__dict__[ name ], name )
        declarations += deftuple[0]
        definitions += fcomment() + deftuple[1]
    # declared only arrays
    declarations += flines ( 'DOUBLE PRECISION units(%i)' %u )
    declarations += flines ( 'DOUBLE PRECISION input(%i)' %i )
    declarations += flines ( 'DOUBLE PRECISION output(%i)' %o )
    
    # call network propagation routine
    callnet = flines ( 'CALL normcall( weights, conec, %i, units, %i, ' %(n, u) )
    callnet += addfline ( 'inno, %i, outno, %i, eni, deo, input, output )'  %(i, o) )
    
    routine = initcomment + fcomment() + \
              fcomment( '-'*66 ) + \
              netroutine  + \
              fcomment( '-'*66 ) + \
              flines( 'EXTERNAL normcall' ) + \
              declarations + \
              definitions + fcomment() + \
              callnet + fcomment() + \
              flines( 'END' )

    return routine
    